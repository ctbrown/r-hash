% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract.R
\docType{methods}
\name{extract}
\alias{extract}
\alias{[,hash,ANY,missing,missing-method}
\alias{[,hash,missing,missing,missing-method}
\alias{[<-,hash,ANY,missing,ANY-method}
\alias{[<-,hash,ANY,missing,NULL-method}
\alias{$<-,hash,NULL-method}
\alias{[[<-,hash,ANY,missing,ANY-method}
\alias{[[<-,hash,ANY,missing,NULL-method}
\title{Extract}
\usage{
\S4method{[}{hash,ANY,missing,missing}(x, i, j, ..., drop = TRUE)

\S4method{[}{hash,missing,missing,missing}(x, i, j, ..., drop = TRUE)

\S4method{[}{hash,ANY,missing,ANY}(x, i, j, ...) <- value

\S4method{[}{hash,ANY,missing,`NULL`}(x, i, j, ...) <- value

\S4method{$}{hash,`NULL`}(x, name) <- value

\S4method{[[}{hash,ANY,missing,ANY}(x, i) <- value

\S4method{[[}{hash,ANY,missing,`NULL`}(x, i) <- value
}
\arguments{
\item{x}{\code{\link[=hash]{hash()}} object}

\item{i}{keys to get or set}

\item{j}{unused; retained to be compatoble with base package}

\item{...}{Arguments passed to additional methods \code{\link[=sapply]{sapply()}}}

\item{drop}{unused; retained to be compatible with base package}

\item{value}{the value to set for the key-value pair}

\item{name}{the key name

\code{$} is a look-up operator for a single key.  The base \code{$} method
are used directly on the inherited environment.  The supplied key is taken
as a string literal and is not interpreted.  The replaement form, \code{$<-}
mutates the hash in place.

\code{[[} is the look-up, extraction operator.  It returns the value of a
single key and will interpret its argument. The replacement method,
\code{[[<-} mutates the hash in place.

\code{[} is a slice operator. It returns a hash with the subset of key-value
pairs. Unlike the other accessor methods, \code{[} returns a \emph{copy}.

All hash key misses return \code{NULL}. All hash key replacements with NULL
delete the key-value pair from the hash.

NAMED ACCESS/REPLACEMENT:

h$x             : returns value of key \code{x};
h$x <- value    : sets key \code{x} to \code{value};
h$x <- NULL     : deletes key-value pair \code{x}

INTERPRETED ACCES/REPLACEMENT:

h[\link{x}]          : returns value of key \code{x}; \code{x} is interpreted.
h[\link{x}] <- value : sets the values of key \code{x}; \code{x} is interpreted.
h[\link{x}] <- NULL  : deletes key-value pair \code{x}; \code{x} is interpreted.

HASH SLICING:
h[]             : returns a copy of h, same as \code{copy(h)}
h\link{x}            : a hash slice of keys

h[] <- value    : error, undefined key
h\link{x} <- value   : set values for keys \code{x} to \code{value}(s)
h\link{x} <- NULL    : delete keys \code{x}

\code{$} and \code{[[} return the value for the supplied argument. If
\code{i} is not a key of \code{x}, \code{NULL} is returned with a warning.

\code{[} returns a hash slice, a subhash copy \code{x} with only the keys
\code{i} defined.

See details above for the complete explanation.}
}
\description{
These are the hash accessor methods. They closely follow the R style.
}
\examples{

  h <- hash( c('a','b','c'), 1:3 )

  # NAMED ACCESS
  
  h$a  # 1
  h$c  # 3
  
  # class of values change automatically
  class(h$a)  # integer
  h$a <- 1.1 
  class(h$a)  # numeric
  
  # values can contain more complex objects
  h$a <- 1:6
  h

  h$a <- NULL  # DELETE key 'a', will return null
  
  
  # INTERPRETED ACCESS
  
  h[[ "a" ]] <-"foo"    # Assigns letters, a vector to "foo"
  nm = "a"
  
  # SLICE ACCESS
  h[ nm ] <- "bar"   # h$a == bar
  h[ nm ] <- NULL
  
  
  # Slice 
  h[ keys(h) ]
  h[ keys(h) ] <- list( 1:2, 1:3 )
  h

}
\seealso{
\code{\link[=del]{del()}} for removing keys
\code{\link[=clear]{clear()}} for removing all keys

\code{\link[=keys]{keys()}} to get/set/rename keys
\code{\link[=values]{values()}} to get/set/edit values

\code{\link[=hash]{hash()}}
}
\author{
Christopher Brown
}
